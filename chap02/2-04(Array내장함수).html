<html>
<head>
    <title>Array 내장함수</title>
</head>
<body>
    <div id="div1">안녕</div>

    <script>
        // 1. toString : 문자열로 바꿈
        var fruits1 = ["Banana", "Orange", "Apple"];
        console.log(fruits1.toString());        // Banana,Orange,Apple

        // 2. join : 배열의 item을 하나의 문자열로 만듦
        console.log(fruits1.join("***"));       // Banana***Orange***Apple

        var txt1 = "Banana";
        txt1 += "Orange";
        txt1 += "Apple";
        console.log(txt1);
        document.getElementById("div1").innerHTML = txt1;
        
        var arr1 = [];
        arr1.push("Banana");
        arr1.push("Orange");
        arr1.push("Apple");
        console.log(arr1);
        document.getElementById("div1").innerHTML= arr1.join("<br>");

        // 3. pop : 배열의 가장 마지막 항목을 제거하여 리턴
        var fruits2 = ["Banana", "Orange", "Apple"];
        var arr2 = fruits2.pop();
        console.log(arr2);          // Apple
        console.log(fruits2);       // ['Banana', 'Orange']

        // 4. push : 배열의 가장 마지막에 새로운 항목 추가
        fruits2.push("Kiwi");
        console.log(fruits2);       // ['Banana', 'Orange', 'Kiwi']

        // 5. shift : 배열의 첫번째 항목을 제거하여 리턴
        var fruits3 = ["Banana", "Orange", "Apple"];
        console.log(fruits3.shift());       // Banana
        console.log(fruits3);               // ['Orange', 'Apple']

        // 6. unshift : 배열의 첫번째에 새로운 항목 추가
        var fruits4 = ["Banana", "Orange", "Apple"];
        fruits4.unshift("Lemon")    // ['Lemon', 'Banana', 'Orange', 'Apple']
        console.log(fruits4);       

        fruits4[0] = "Grape";   // Lemon => Grape
        console.log(fruits4);

        fruits4[fruits4.length - 1] = "Peach"
        console.log(fruits4);       // 마지막 값이 Peach로 바뀜

        // 7. splice(a, b) : a = 시작 위치, b = 삭제할 항목 수 (배열 추가와 삭제가 가능)
        var fruits5 = ["Banana", "Orange", "Apple"];
        // fruits5.splice(1, 2);
        // console.log(fruits5);       // ['Banana']
        // fruits5.splice(1, 0, "Lemon", "Kiwi");      // 1번째에 0개 삭제하고 두개 추가
        fruits5.splice(1, 1, "Lemon");      // 1번째에 1개 삭제하고 한개 추가

        // 8. concat : 두개의 배열을 하나로 만듦
        var BTS1 = ["뷔"];
        var BTS2 = ["정국", "RM"];
        var BTS = BTS1.concat(BTS2);
        console.log(BTS);       // ['뷔', '정국', 'RM']

        // 9. slice(a, b) : a부터 b-1까지 항목을 가져옴
        var fruits6 = ["Banana", "Orange", "Apple"];
        // var fruits7 = fruit6.slice(1);    
        var fruits7 = fruits6.slice(1, 2);      // ['Orange']
        console.log(fruits7);

        // 10. sort : 오름차순 정렬
        var fruits8 = ["Banana", "Orange", "Apple", "Lemon", "Kiwi"];
        console.log(fruits8.sort());

        var points = [40, 100, 70, 21, 99];
        console.log(points.sort());          // 숫자를 문자로 인식하여 오름차순 정렬

        // points.sort( function(a,b){
        //     if(a > b)
        //         return 1;       // return true
        //     else
        //         return -1;      // return false
        // })

        points.sort( function(a, b){
            return a - b;       // return b - a
        });

        console.log(points.reverse());

        console.log(points);        // 오름차순 정렬됨

        // object 정렬
        var persons = [
            {name: "유재석", point: 78},
            {name: "김종국", point: 92},
            {name: "양세찬", point: 76},
            {name: "하  하", point: 80}
        ];
        // console.log(persons.sort());   // object에는 정렬이 적용되지 않음
        persons.sort(function(a, b){
            if(a.point > b.point)
                return 1;       // -1
            else
                return -1;      // 1
        });
        console.log(persons);

        persons.sort(function(a, b){
            // 삼항 연산자 이용
            return a.point > b.point ? 1 : -1;
        });

        // !!!중요!!!
        // 11. filter : 조건에 맞는 배열만 리턴
        // var persons = [
        //     {name: "유재석", point: 78},
        //     {name: "김종국", point: 92},
        //     {name: "양세찬", point: 76},
        //     {name: "하  하", point: 80}
        // ];

        var pass = persons.filter(function(per){
            return per.point > 80;
        });

        var persons = [
            {name: "유재석", point: 78, city: "서울"},
            {name: "김종국", point: 92, city: "대구"},
            {name: "양세찬", point: 76, city: "서울"},
            {name: "하  하", point: 80, city: "제주"}
        ];

        // filter를 for문으로 구현하면 복잡함
        var seoul = persons.filter(function(per){
            return per.city === "서울";
        })
        console.log(seoul);

        // !!!중요!!!
        // 12. reduce(a, c) : 
        // a : accumulator = 누산기
        // c : currentValue = 현재값  
        var arr3 = [1, 2, 3, 4];
        var total = arr3.reduce(function(a,c){
            return a + c;
        });
        console.log(total);
        
        // map!!!!!!!!! : 필터랑 비슷함! 근데 중요!!
        var userList = [
            {firstName:"재석", lastName:"유", email:"yu@email.com"},
            {firstName:"종국", lastName:"김", email:"kim@email.com"},
            {firstName:"세찬", lastName:"양", email:"yang@email.com"},
            {firstName:"석진", lastName:"지", email:"ji@email.com"}
        ]
        
        var userList2 = userList.map(function(user) {
            return {fullName:user.lastName + user.firstName, FN:user.firstName, lN:user.lastName}
        });

        console.log(userList2);
    </script>
</body>
</html>